# Makefile for managing the AWS infrastructure


# .ONESHELL Tells Make to execute all lines within a recipe in a single shell instance. 
# This is crucial for heredocs to work correctly, as they are a shell feature and 
# require the entire block to be processed by a single shell.
.ONESHELL:


# Variables
# TF_STATE_BACKEND_DIR := infra_mgmt/bootstrap/state-backend
# TF_ORG_DIR := infra_mgmt/org
# TF_ENVS_DIR := infra_mgmt/environments

# Absolute path to the directory containing this Makefile
MAKEFILE_DIR := $(abspath $(dir $(lastword $(MAKEFILE_LIST))))

# User configs dir
USER_CONFIG_DIR := $(MAKEFILE_DIR)/proto_configs
PROJECTS_CONFIG := $(USER_CONFIG_DIR)/projects.yaml

# "Package" dir
INFRA_DIR := $(MAKEFILE_DIR)/infra_mgmt

# Overall collection of Terraform projects
TERRAFORM_DIR := $(INFRA_DIR)/terraform
BUILD_DIR := $(TERRAFORM_DIR)/.build
MODULES_DIR := $(TERRAFORM_DIR)/modules

# Terraform (bootstrapped) backend dir and files
BACKEND_DIR := $(TERRAFORM_DIR)/backend
BACKEND_OUTPUT := $(BACKEND_DIR)/bootstrap.json
BACKEND_HCL := $(BACKEND_DIR)/backend.hcl

CONFIG_DIR := $(TERRAFORM_DIR)/.config
ACCOUNTS_CONFIG := $(CONFIG_DIR)/accounts.json
ACCOUNTS_OUTPUT := $(CONFIG_DIR)/accounts_output.json

LOGS_DIR := $(TERRAFORM_DIR)/.logs

# Terraform accounts creation mgmt
ACCOUNTS_DIR := $(TERRAFORM_DIR)/accounts

# Initial IAM user mgmt
IAM_DIR := $(BUILD_DIR)/iam
IAM_CONFIG := $(CONFIG_DIR)/iam_users.json
IAM_OUTPUT := $(CONFIG_DIR)/iam_output.json
IAM_MODULE := $(MODULES_DIR)/iam_users_groups

# Terraform org mgmt
ORG_DIR := $(TERRAFORM_DIR)/.build/org
ORG_BUILD_OUTPUT_DIR := $(ORG_DIR)/.output


.PHONY: all show-paths bootstrap backend-init backend-config accounts org

# Default target
all: bootstrap backend-config accounts org

show-paths:
	@echo "Makefile dir: $(MAKEFILE_DIR)"
	@echo "Bootstrap dir: $(BACKEND_DIR)"

# Step 1: Apply bootstrap (creates S3 + DynamoDB backend infra)
bootstrap:
	@echo "\n>>> Generating backend terraform.tfvars..."
	python -m infra_mgmt.python.bin.backend $(USER_CONFIG_DIR)/config.yaml $(BACKEND_DIR)
	@echo "\n>>> Bootstrapping backend..."
	terraform -chdir=$(BACKEND_DIR) init
	terraform -chdir=$(BACKEND_DIR) apply -auto-approve


# Step 2: Generate backend.hcl file from bootstrap outputs
backend-config: bootstrap
	@echo "\n>>> Generating backend.hcl from bootstrap outputs..."
	@cat > $(BACKEND_HCL) <<EOF
	bucket         = "$$(terraform -chdir=$(BACKEND_DIR) output -raw s3_bucket_name)"
	dynamodb_table = "$$(terraform -chdir=$(BACKEND_DIR) output -raw dynamodb_table_name)"
	region         = "$$(terraform -chdir=$(BACKEND_DIR) output -raw region)"
	profile        = "$$(terraform -chdir=$(BACKEND_DIR) output -raw profile)"
	EOF
	@echo "backend.hcl created:"
	@cat $(BACKEND_HCL)


accounts-init: backend-config
	@echo "\n>>> Generating accounts.json..."
	python -m infra_mgmt.python.bin.accounts $(USER_CONFIG_DIR)/config.yaml $(ACCOUNTS_CONFIG)
	@echo "\n>>> Initializing for accounts..."
	terraform -chdir=$(ACCOUNTS_DIR) init \
	  -backend-config=$(BACKEND_HCL) \
	  -backend-config="key=accounts/terraform.tfstate"

accounts-plan: 
	@echo "\n>>> Planning accounts..."
	terraform -chdir=$(ACCOUNTS_DIR) plan -var-file=$(ACCOUNTS_CONFIG)

accounts-apply: accounts-init
	@echo "\n>>> Applying accounts..."
	terraform -chdir=$(ACCOUNTS_DIR) apply -auto-approve -var-file=$(ACCOUNTS_CONFIG)
	@echo "\n>>> Fetching accounts output..."
	terraform -chdir=$(ACCOUNTS_DIR) output -json > $(ACCOUNTS_OUTPUT)
	@echo "Done!"

iam-config: 
	@echo "\n>>> Configuring IAM..."
	python -m infra_mgmt.python.bin.iam $(USER_CONFIG_DIR)/config.yaml $(ACCOUNTS_OUTPUT) $(IAM_CONFIG) $(IAM_DIR) $(IAM_MODULE)


iam-init: backend-config iam-config
	@echo "\n>>> Initializing for IAM..."
	terraform -chdir=$(IAM_DIR) init \
	  -backend-config=$(BACKEND_HCL) \
	  -backend-config="key=init_iam/terraform.tfstate"

iam-plan: 
	@echo "\n>>> Planning init-iam..."
	terraform -chdir=$(IAM_DIR) plan -var-file=$(IAM_CONFIG)

iam-apply: 
	@echo "\n>>> Applying IAM..."
	terraform -chdir=$(IAM_DIR) apply -auto-approve -var-file=$(IAM_CONFIG)
	@echo "\n>>> Fetching IAM output..."
	terraform -chdir=$(IAM_DIR) output -json > $(IAM_OUTPUT)

org-config:
	@echo "\n>>> Configuring ORG..."
	python -m infra_mgmt.python.bin.org $(USER_CONFIG_DIR)/config.yaml $(ACCOUNTS_OUTPUT) $(IAM_CONFIG) $(ORG_DIR) 

org-init:
	@echo "\n>>> Initializing org environments..."
	@mkdir -p $(LOGS_DIR)
	@for dir in $$(find $(ORG_DIR) -mindepth 1 -maxdepth 1 -type d -not -name '.*' -exec basename {} \;); do \
		mkdir -p $(LOGS_DIR)/$$dir
		echo "\n>>> Initializing for account: $$dir..."; \
		(terraform -chdir=$(ORG_DIR)/$$dir init -no-color \
		  -backend-config=$(BACKEND_HCL) \
		  -backend-config="key=org/$$dir/terraform.tfstate" 2>&1 | tee $(LOGS_DIR)/$$dir/$$dir-init.log); \
	done

org-plan:
	@echo "\n>>> Planning org environments..."
	@for dir in $$(find $(ORG_DIR) -mindepth 1 -maxdepth 1 -type d -not -name '.*' -exec basename {} \;); do \
		echo "\n>>> Planning for account: $$dir..."; \
		(terraform -chdir=$(ORG_DIR)/$$dir plan -no-color 2>&1 \
		  | tee $(LOGS_DIR)/$$dir/$$dir-planning.log); \
	done

org-apply:
	@echo "\n>>> Applying org environments..."
	@mkdir -p $(ORG_BUILD_OUTPUT_DIR)
	@for dir in $$(find $(ORG_DIR) -mindepth 1 -maxdepth 1 -type d -not -name '.*' -exec basename {} \;); do \
		echo "\n>>> Applying for account: $$dir..."; \
		(terraform -chdir=$(ORG_DIR)/$$dir apply -auto-approve -no-color 2>&1 \
		  | tee $(LOGS_DIR)/$$dir/$$dir-applying.log); \
		echo "\n>>> Fetching outputs for account: $$dir..."; \
		terraform -chdir=$(ORG_DIR)/$$dir output -json > $(ORG_BUILD_OUTPUT_DIR)/$$dir.json; 
	done



# Step 6 (Option A): Generate VPN config for a single user
.PHONY: vpn-config
vpn-config:
	@if [ -z "$(account)" ]; then \
		echo "ERROR: 'account' argument is required."; \
		echo "Usage: make vpn-config account=<account_alias> user=<user_name>"; \
		exit 1; \
	fi
	@if [ -z "$(user)" ]; then \
		echo "ERROR: 'user' argument is required."; \
		echo "Usage: make vpn-config account=<account_alias> user=<user_name>"; \
		exit 1; \
	fi

	ACCOUNT_ALIAS=$(account)
	USER_NAME=$(user)
	ACCOUNT_DIR=$(ORG_DIR)/$(ACCOUNT_ALIAS)
	CERT_DIR=$(TERRAFORM_DIR)/.client_vpn_configs/$(ACCOUNT_ALIAS)
	USER_CERT_PATH=$(CERT_DIR)/$(USER_NAME).crt
	USER_KEY_PATH=$(CERT_DIR)/$(USER_NAME).key
	OUTPUT_DIR=generated_vpn_configs/$(ACCOUNT_ALIAS)
	OVPN_FILE=$(OUTPUT_DIR)/$(USER_NAME).ovpn

	# This profile is used to assume the OrganizationAccountAccessRole in the target account.
	# It's defined in proto_configs/config.yaml
	AWS_PROFILE=pulse-infra-admin
	AWS_REGION=us-west-2

	@echo "\n>>> Generating VPN config for user '$(USER_NAME)' in account '$(ACCOUNT_ALIAS)'..."

	@if [ ! -f "$(USER_CERT_PATH)" ] || [ ! -f "$(USER_KEY_PATH)" ]; then \
		echo "ERROR: Certificate or key file not found for user '$(USER_NAME)' in account '$(ACCOUNT_ALIAS)'."; \
		echo "Searched for: $(USER_CERT_PATH) and $(USER_KEY_PATH)"; \
		echo "Please ensure 'make org-apply' has been run successfully and the user has 'vpn_access: true'."; \
		exit 1; \
	fi

	@mkdir -p $(OUTPUT_DIR)

	@echo "--> Fetching VPN Endpoint ID from Terraform state..."
	VPN_ENDPOINT_ID=$$(terraform -chdir=$(ACCOUNT_DIR) output -raw client_vpn_endpoint_id)
	@if [ -z "$$VPN_ENDPOINT_ID" ]; then \
		echo "ERROR: Could not fetch VPN Endpoint ID for account '$(ACCOUNT_ALIAS)'."; \
		exit 1; \
	fi

	@echo "--> Downloading base VPN configuration from AWS..."
	aws ec2 export-client-vpn-client-configuration \
		--client-vpn-endpoint-id $$VPN_ENDPOINT_ID \
		--profile $(AWS_PROFILE) \
		--region $(AWS_REGION) \
		--output text > $(OVPN_FILE)

	@echo "--> Appending user certificate and key to configuration..."
	echo -e '\n<cert>' >> $(OVPN_FILE)
	cat $(USER_CERT_PATH) >> $(OVPN_FILE)
	echo '</cert>' >> $(OVPN_FILE)

	echo -e '\n<key>' >> $(OVPN_FILE)
	cat $(USER_KEY_PATH) >> $(OVPN_FILE)
	echo '</key>' >> $(OVPN_FILE)

	@echo "\n>>> Success!"
	@echo "VPN configuration file created at: $(OVPN_FILE)"
	@echo "Please distribute this file securely to the user."

# Step 6 (Option B): Generate VPN configs for ALL users with generated certs
.PHONY: vpn-configs-all
vpn-configs-all:
	@echo "\n>>> Generating all possible VPN configuration files..."
	GENERATED_VPN_DIR=generated_vpn_configs
	@mkdir -p $(GENERATED_VPN_DIR)

	# This profile is used to assume the OrganizationAccountAccessRole in the target account.
	# It's defined in proto_configs/config.yaml
	AWS_PROFILE=pulse-infra-admin
	AWS_REGION=us-west-2

	@for key_file in $$(find $(TERRAFORM_DIR)/.client_vpn_configs -name "*.key"); do \
		USER_NAME=$$(basename $$key_file .key); \
		ACCOUNT_ALIAS=$$(basename $$(dirname $$key_file)); \
		ACCOUNT_DIR=$(ORG_DIR)/$$ACCOUNT_ALIAS; \
		USER_CERT_PATH=$$(dirname $$key_file)/$$USER_NAME.crt; \
		OUTPUT_DIR=$(GENERATED_VPN_DIR)/$$ACCOUNT_ALIAS; \
		OVPN_FILE=$$OUTPUT_DIR/$$USER_NAME.ovpn; \
		\
		echo "\n--> Found cert for user '$$USER_NAME' in account '$$ACCOUNT_ALIAS'. Generating config..."; \
		mkdir -p $$OUTPUT_DIR; \
		\
		VPN_ENDPOINT_ID=$$(terraform -chdir=$$ACCOUNT_DIR output -raw client_vpn_endpoint_id); \
		if [ -z "$$VPN_ENDPOINT_ID" ]; then \
			echo "ERROR: Could not fetch VPN Endpoint ID for account '$$ACCOUNT_ALIAS'. Skipping."; \
			continue; \
		fi; \
		\
		aws ec2 export-client-vpn-client-configuration \
			--client-vpn-endpoint-id $$VPN_ENDPOINT_ID \
			--profile $(AWS_PROFILE) \
			--region $(AWS_REGION) \
			--output text > $$OVPN_FILE; \
		\
		echo -e '\n<cert>' >> $$OVPN_FILE; \
		cat $$USER_CERT_PATH >> $$OVPN_FILE; \
		echo '</cert>' >> $$OVPN_FILE; \
		\
		echo -e '\n<key>' >> $$OVPN_FILE; \
		cat $$key_file >> $$OVPN_FILE; \
		echo '</key>' >> $$OVPN_FILE; \
	done

	@echo "\n>>> Success!"
	@echo "All available VPN configuration files have been created in: $(GENERATED_VPN_DIR)"